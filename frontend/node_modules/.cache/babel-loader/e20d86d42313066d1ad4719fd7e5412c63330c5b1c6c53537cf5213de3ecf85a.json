{"ast":null,"code":"var _jsxFileName = \"/Users/fitzpatrickcarl/my-musical-stairs-app/src/Score.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from 'react';\nimport VexFlow from 'vexflow';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VF = VexFlow.Flow;\nconst {\n  Formatter,\n  Renderer,\n  Stave,\n  StaveNote\n} = VF;\nconst clefAndTimeWidth = 60;\nexport function Score({\n  staves = [],\n  clef = 'treble',\n  timeSignature = '4/4',\n  initialWidth = 1000,\n  height = 150\n}) {\n  _s();\n  const container = useRef();\n  const rendererRef = useRef();\n  useEffect(() => {\n    if (rendererRef.current == null) {\n      rendererRef.current = new Renderer(container.current, Renderer.Backends.SVG);\n    }\n    const renderer = rendererRef.current;\n    const screenWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n    const scaleFactor = screenWidth < initialWidth ? screenWidth / initialWidth : 1;\n    renderer.resize(initialWidth * scaleFactor, height);\n    const context = renderer.getContext();\n    context.setFont('Arial', 10, '').setBackgroundFillStyle('#eed');\n    let currX = 0;\n    let accumulatedWidth = 0;\n    staves.forEach((notes, i) => {\n      const staveWidth = (i === 0 ? initialWidth - clefAndTimeWidth : initialWidth) * scaleFactor / staves.length;\n      const stave = new Stave(currX, 0, staveWidth);\n      if (i === 0) {\n        stave.setWidth(staveWidth + clefAndTimeWidth * scaleFactor / staves.length);\n        stave.addClef(clef).addTimeSignature(timeSignature);\n      }\n      accumulatedWidth += stave.getWidth();\n      if (accumulatedWidth > initialWidth * scaleFactor) {\n        // Move to the next line\n        currX = 0;\n        accumulatedWidth = stave.getWidth();\n      }\n      stave.setContext(context).draw();\n      const processedNotes = notes.map(note => typeof note === 'string' ? {\n        key: note\n      } : note).map(note => Array.isArray(note) ? {\n        key: note[0],\n        duration: note[1]\n      } : note).map(({\n        key,\n        ...rest\n      }) => ({\n        key: typeof key === 'string' ? `${key[0]}/${key.slice(1)}` : key,\n        ...rest\n      })).map(({\n        key,\n        keys,\n        duration = 'q'\n      }) => new StaveNote({\n        keys: key ? [key] : keys,\n        duration: String(duration)\n      }));\n      Formatter.FormatAndDraw(context, stave, processedNotes, {\n        auto_beam: true\n      });\n      currX += stave.getWidth();\n    });\n  }, [staves, initialWidth, clef, timeSignature]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: container\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 76,\n    columnNumber: 10\n  }, this);\n}\n_s(Score, \"Oo94nw6YKmif0GbcQr28f6bFgJU=\");\n_c = Score;\nvar _c;\n$RefreshReg$(_c, \"Score\");","map":{"version":3,"names":["React","useRef","useEffect","VexFlow","jsxDEV","_jsxDEV","VF","Flow","Formatter","Renderer","Stave","StaveNote","clefAndTimeWidth","Score","staves","clef","timeSignature","initialWidth","height","_s","container","rendererRef","current","Backends","SVG","renderer","screenWidth","window","innerWidth","document","documentElement","clientWidth","body","scaleFactor","resize","context","getContext","setFont","setBackgroundFillStyle","currX","accumulatedWidth","forEach","notes","i","staveWidth","length","stave","setWidth","addClef","addTimeSignature","getWidth","setContext","draw","processedNotes","map","note","key","Array","isArray","duration","rest","slice","keys","String","FormatAndDraw","auto_beam","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/fitzpatrickcarl/my-musical-stairs-app/src/Score.js"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\nimport VexFlow from 'vexflow';\n\nconst VF = VexFlow.Flow;\nconst { Formatter, Renderer, Stave, StaveNote } = VF;\n\nconst clefAndTimeWidth = 60;\n\nexport function Score({\n  staves = [],\n  clef = 'treble',\n  timeSignature = '4/4',\n  initialWidth = 1000,\n  height = 150,\n}) {\n  const container = useRef();\n  const rendererRef = useRef();\n\n  useEffect(() => {\n    if (rendererRef.current == null) {\n      rendererRef.current = new Renderer(\n        container.current,\n        Renderer.Backends.SVG\n      );\n    }\n    const renderer = rendererRef.current;\n    const screenWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n    const scaleFactor = screenWidth < initialWidth ? screenWidth / initialWidth : 1;\n\n    renderer.resize(initialWidth * scaleFactor, height);\n    const context = renderer.getContext();\n    context.setFont('Arial', 10, '').setBackgroundFillStyle('#eed');\n\n    let currX = 0;\n    let accumulatedWidth = 0;\n\n    staves.forEach((notes, i) => {\n      const staveWidth = (i === 0 ? initialWidth - clefAndTimeWidth : initialWidth) * scaleFactor / staves.length;\n      const stave = new Stave(currX, 0, staveWidth);\n      if (i === 0) {\n        stave.setWidth(staveWidth + clefAndTimeWidth * scaleFactor / staves.length);\n        stave.addClef(clef).addTimeSignature(timeSignature);\n      }\n\n      accumulatedWidth += stave.getWidth();\n      if (accumulatedWidth > initialWidth * scaleFactor) {\n        // Move to the next line\n        currX = 0;\n        accumulatedWidth = stave.getWidth();\n      }\n\n      stave.setContext(context).draw();\n\n      const processedNotes = notes\n        .map((note) => (typeof note === 'string' ? { key: note } : note))\n        .map((note) =>\n          Array.isArray(note) ? { key: note[0], duration: note[1] } : note\n        )\n        .map(({ key, ...rest }) => ({\n          key: typeof key === 'string' ? `${key[0]}/${key.slice(1)}` : key,\n          ...rest,\n        }))\n        .map(({ key, keys, duration = 'q' }) => new StaveNote({\n          keys: key ? [key] : keys,\n          duration: String(duration),\n        }));\n\n      Formatter.FormatAndDraw(context, stave, processedNotes, {\n        auto_beam: true,\n      });\n\n      currX += stave.getWidth();\n    });\n  }, [staves, initialWidth, clef, timeSignature]);\n\n  return <div ref={container} />;\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}